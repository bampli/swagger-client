# coding: utf-8

"""
    bampli-api

    The API for the Business Amplifier project.  # noqa: E501

    OpenAPI spec version: 1.0.0-oas3
    Contact: josemotta@bampli.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CycloApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_cyclo(self, body, **kwargs):  # noqa: E501
        """Create a new Cyclo  # noqa: E501

        Adds a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cyclo(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Cyclo body: (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_cyclo_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_cyclo_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_cyclo_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new Cyclo  # noqa: E501

        Adds a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cyclo_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Cyclo body: (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_cyclo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_cyclo`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/cyclo/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cyclo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_stage(self, body, **kwargs):  # noqa: E501
        """Create a new Stage  # noqa: E501

        Adds a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_stage(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Stage body: (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_stage_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_stage_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_stage_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new Stage  # noqa: E501

        Adds a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_stage_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Stage body: (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/stage/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Stage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_task(self, body, **kwargs):  # noqa: E501
        """Create a new Task  # noqa: E501

        Adds a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_task(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body: (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_task_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_task_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_task_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new Task  # noqa: E501

        Adds a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_task_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body: (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/task/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cyclo(self, cycloid, **kwargs):  # noqa: E501
        """Delete a Cyclo  # noqa: E501

        Deletes a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cyclo(cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cycloid: Identifier of the Cyclo (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cyclo_with_http_info(cycloid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cyclo_with_http_info(cycloid, **kwargs)  # noqa: E501
            return data

    def delete_cyclo_with_http_info(self, cycloid, **kwargs):  # noqa: E501
        """Delete a Cyclo  # noqa: E501

        Deletes a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cyclo_with_http_info(cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cycloid: Identifier of the Cyclo (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cycloid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cyclo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cycloid' is set
        if ('cycloid' not in params or
                params['cycloid'] is None):
            raise ValueError("Missing the required parameter `cycloid` when calling `delete_cyclo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cycloid' in params:
            path_params['cycloid'] = params['cycloid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/cyclo/{cycloid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_stage(self, stageid, **kwargs):  # noqa: E501
        """Delete a Stage  # noqa: E501

        Deletes a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_stage(stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stageid: Identifier of the Stage (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_stage_with_http_info(stageid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_stage_with_http_info(stageid, **kwargs)  # noqa: E501
            return data

    def delete_stage_with_http_info(self, stageid, **kwargs):  # noqa: E501
        """Delete a Stage  # noqa: E501

        Deletes a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_stage_with_http_info(stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stageid: Identifier of the Stage (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stageid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stageid' is set
        if ('stageid' not in params or
                params['stageid'] is None):
            raise ValueError("Missing the required parameter `stageid` when calling `delete_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stageid' in params:
            path_params['stageid'] = params['stageid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/stage/{stageid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_task(self, taskid, **kwargs):  # noqa: E501
        """Delete a Task  # noqa: E501

        Deletes a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task(taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskid: Identifier of the Task (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_task_with_http_info(taskid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_task_with_http_info(taskid, **kwargs)  # noqa: E501
            return data

    def delete_task_with_http_info(self, taskid, **kwargs):  # noqa: E501
        """Delete a Task  # noqa: E501

        Deletes a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task_with_http_info(taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskid: Identifier of the Task (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['taskid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'taskid' is set
        if ('taskid' not in params or
                params['taskid'] is None):
            raise ValueError("Missing the required parameter `taskid` when calling `delete_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'taskid' in params:
            path_params['taskid'] = params['taskid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/task/{taskid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cyclo(self, cycloid, **kwargs):  # noqa: E501
        """Load an individual Cyclo  # noqa: E501

        Loads a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cyclo(cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cycloid: Identifier of the Cyclo (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cyclo_with_http_info(cycloid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cyclo_with_http_info(cycloid, **kwargs)  # noqa: E501
            return data

    def get_cyclo_with_http_info(self, cycloid, **kwargs):  # noqa: E501
        """Load an individual Cyclo  # noqa: E501

        Loads a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cyclo_with_http_info(cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cycloid: Identifier of the Cyclo (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cycloid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cyclo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cycloid' is set
        if ('cycloid' not in params or
                params['cycloid'] is None):
            raise ValueError("Missing the required parameter `cycloid` when calling `get_cyclo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cycloid' in params:
            path_params['cycloid'] = params['cycloid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cyclo/{cycloid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cyclo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_stage(self, stageid, **kwargs):  # noqa: E501
        """Load an individual Stage  # noqa: E501

        Loads a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stage(stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stageid: Identifier of the Stage (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_stage_with_http_info(stageid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_stage_with_http_info(stageid, **kwargs)  # noqa: E501
            return data

    def get_stage_with_http_info(self, stageid, **kwargs):  # noqa: E501
        """Load an individual Stage  # noqa: E501

        Loads a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stage_with_http_info(stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stageid: Identifier of the Stage (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stageid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stageid' is set
        if ('stageid' not in params or
                params['stageid'] is None):
            raise ValueError("Missing the required parameter `stageid` when calling `get_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stageid' in params:
            path_params['stageid'] = params['stageid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stage/{stageid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Stage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task(self, taskid, **kwargs):  # noqa: E501
        """Load an individual Task  # noqa: E501

        Loads a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task(taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskid: Identifier of the Task (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_task_with_http_info(taskid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_task_with_http_info(taskid, **kwargs)  # noqa: E501
            return data

    def get_task_with_http_info(self, taskid, **kwargs):  # noqa: E501
        """Load an individual Task  # noqa: E501

        Loads a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_with_http_info(taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str taskid: Identifier of the Task (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['taskid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'taskid' is set
        if ('taskid' not in params or
                params['taskid'] is None):
            raise ValueError("Missing the required parameter `taskid` when calling `get_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'taskid' in params:
            path_params['taskid'] = params['taskid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/task/{taskid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cyclos(self, **kwargs):  # noqa: E501
        """Load the list of Cyclos  # noqa: E501

        Loads list of Cyclos  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cyclos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results.
        :param str name: Allows to filter the collections of result by name
        :param str company_id: Allows to filter the collections of result by company_id
        :return: list[Cyclo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_cyclos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_cyclos_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_cyclos_with_http_info(self, **kwargs):  # noqa: E501
        """Load the list of Cyclos  # noqa: E501

        Loads list of Cyclos  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cyclos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results.
        :param str name: Allows to filter the collections of result by name
        :param str company_id: Allows to filter the collections of result by company_id
        :return: list[Cyclo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'sort', 'name', 'company_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cyclos" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('$size', params['size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('$page', params['page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('$sort', params['sort']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'company_id' in params:
            query_params.append(('company_id', params['company_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cyclo/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Cyclo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_stages(self, **kwargs):  # noqa: E501
        """Load the list of Stages  # noqa: E501

        Loads list of Stages  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results. Multiple sort criteria can be passed. Example: sort=name ASC
        :param str name: Allows to filter the collections of result by name
        :param str cyclo_id: Allows to filter the collections of result by cyclo_id
        :return: list[Stage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_stages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_stages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_stages_with_http_info(self, **kwargs):  # noqa: E501
        """Load the list of Stages  # noqa: E501

        Loads list of Stages  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_stages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results. Multiple sort criteria can be passed. Example: sort=name ASC
        :param str name: Allows to filter the collections of result by name
        :param str cyclo_id: Allows to filter the collections of result by cyclo_id
        :return: list[Stage]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'sort', 'name', 'cyclo_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_stages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('$size', params['size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('$page', params['page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('$sort', params['sort']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'cyclo_id' in params:
            query_params.append(('cyclo_id', params['cyclo_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stage/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Stage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_tasks(self, **kwargs):  # noqa: E501
        """Load the list of Tasks  # noqa: E501

        Loads list of Tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tasks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results. Multiple sort criteria can be passed. Example: sort=name ASC,city DESC
        :param str name: Allows to filter the collections of result by name
        :param str stage_id: Allows to filter the collections of result by stage_id
        :return: list[Task]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """Load the list of Tasks  # noqa: E501

        Loads list of Tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tasks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int size: Size of the page to retrieve.
        :param float page: Number of the page to retrieve.
        :param str sort: Order in which to retrieve the results. Multiple sort criteria can be passed. Example: sort=name ASC,city DESC
        :param str name: Allows to filter the collections of result by name
        :param str stage_id: Allows to filter the collections of result by stage_id
        :return: list[Task]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['size', 'page', 'sort', 'name', 'stage_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_tasks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'size' in params:
            query_params.append(('$size', params['size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('$page', params['page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('$sort', params['sort']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'stage_id' in params:
            query_params.append(('stage_id', params['stage_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/task/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Task]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cyclo(self, body, cycloid, **kwargs):  # noqa: E501
        """Update a Cyclo  # noqa: E501

        Stores a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cyclo(body, cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Cyclo body: (required)
        :param str cycloid: Identifier of the Cyclo (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cyclo_with_http_info(body, cycloid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cyclo_with_http_info(body, cycloid, **kwargs)  # noqa: E501
            return data

    def update_cyclo_with_http_info(self, body, cycloid, **kwargs):  # noqa: E501
        """Update a Cyclo  # noqa: E501

        Stores a Cyclo  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cyclo_with_http_info(body, cycloid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Cyclo body: (required)
        :param str cycloid: Identifier of the Cyclo (required)
        :return: Cyclo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cycloid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cyclo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cyclo`")  # noqa: E501
        # verify the required parameter 'cycloid' is set
        if ('cycloid' not in params or
                params['cycloid'] is None):
            raise ValueError("Missing the required parameter `cycloid` when calling `update_cyclo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cycloid' in params:
            path_params['cycloid'] = params['cycloid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/cyclo/{cycloid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Cyclo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_stage(self, body, stageid, **kwargs):  # noqa: E501
        """Update a Stage  # noqa: E501

        Stores a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_stage(body, stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Stage body: (required)
        :param str stageid: Identifier of the Stage (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_stage_with_http_info(body, stageid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_stage_with_http_info(body, stageid, **kwargs)  # noqa: E501
            return data

    def update_stage_with_http_info(self, body, stageid, **kwargs):  # noqa: E501
        """Update a Stage  # noqa: E501

        Stores a Stage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_stage_with_http_info(body, stageid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Stage body: (required)
        :param str stageid: Identifier of the Stage (required)
        :return: Stage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'stageid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_stage`")  # noqa: E501
        # verify the required parameter 'stageid' is set
        if ('stageid' not in params or
                params['stageid'] is None):
            raise ValueError("Missing the required parameter `stageid` when calling `update_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stageid' in params:
            path_params['stageid'] = params['stageid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/stage/{stageid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Stage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, body, taskid, **kwargs):  # noqa: E501
        """Update a Task  # noqa: E501

        Stores a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(body, taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body: (required)
        :param str taskid: Identifier of the Task (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(body, taskid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(body, taskid, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, body, taskid, **kwargs):  # noqa: E501
        """Update a Task  # noqa: E501

        Stores a Task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(body, taskid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Task body: (required)
        :param str taskid: Identifier of the Task (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'taskid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_task`")  # noqa: E501
        # verify the required parameter 'taskid' is set
        if ('taskid' not in params or
                params['taskid'] is None):
            raise ValueError("Missing the required parameter `taskid` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'taskid' in params:
            path_params['taskid'] = params['taskid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HTTP_BASIC']  # noqa: E501

        return self.api_client.call_api(
            '/task/{taskid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
